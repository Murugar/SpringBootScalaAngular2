// Generated by CoffeeScript 1.4.0



(function() {
  var StompServerMock, console,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

   
    var WebSocketMock = require('./websocket.mock.js').WebSocketMock;

  StompServerMock = (function(_super) {

    __extends(StompServerMock, _super);

    function StompServerMock() {
      this.handle_open = __bind(this.handle_open, this);

      this.handle_close = __bind(this.handle_close, this);

      this.handle_send = __bind(this.handle_send, this);
      
    

      var Stomp = require('./stomp.js').Stomp;
      //console = require('console')

      var Frame = Stomp.Frame;
      
      return StompServerMock.__super__.constructor.apply(this, arguments);
    }

    StompServerMock.prototype.handle_send = function(msg) {
      //console.log("StompServerMock: Dirty Crap1: ");
      return this.stomp_dispatch(Stomp.Frame.unmarshall(msg).frames[0]);
    
     //var frames = Stomp.Frame.unmarshall(msg);
    	
      //return this.stomp_dispatch(frames[0]);
    };

    StompServerMock.prototype.handle_close = function() {
      return this._shutdown();
    };

    StompServerMock.prototype.handle_open = function() {
      this.stomp_init();
      return this._accept();
    };

    StompServerMock.prototype.stomp_init = function() {
      this.transactions = {};
      this.subscriptions = {};
      return this.messages = [];
    };

    StompServerMock.prototype.stomp_send = function(command, headers, body) {
    //	console.log("StompServerMock: Dirty Crap1: ");		
      if (body == null) {
        body = null;
      }
      return this._respond(Stomp.Frame.marshall(command, headers, body));
    };

    StompServerMock.prototype.stomp_send_receipt = function(frame) {
      if (frame.headers.message != null) {
        return this.stomp_send("ERROR", {
          'receipt-id': frame.headers['receipt-id'],
          'message': frame.headers.message
        });
      } else {
        return this.stomp_send("RECEIPT", {
          'receipt-id': frame.headers['receipt-id']
        });
      }
    };

    StompServerMock.prototype.stomp_send_message = function(destination, subscription, message_id, body) {
      return this.stomp_send("MESSAGE", {
        'destination': destination,
        'message-id': message_id,
        'subscription': subscription
      }, body);
    };

    StompServerMock.prototype.stomp_dispatch = function(frame) {
      	
      var handler;
      handler = "stomp_handle_" + (frame.command.toLowerCase());
      if (this[handler] != null) {
        this[handler](frame);
        if (frame.receipt) {
          return this.stomp_send_receipt(frame);
        }
      } else {
        return console.log("StompServerMock: Unknown command: " + frame.command);
      }
    };

    StompServerMock.prototype.stomp_handle_connect = function(frame) {
      this.session_id = Math.random();
      return this.stomp_send("CONNECTED", {
        'session': this.session_id
      });
    };

    StompServerMock.prototype.stomp_handle_begin = function(frame) {
      return this.transactions[frame.headers.transaction] = [];
    };

    StompServerMock.prototype.stomp_handle_commit = function(frame) {
      var transaction, _i, _len;
      transaction = this.transactions[frame.headers.transaction];
      for (_i = 0, _len = transaction.length; _i < _len; _i++) {
        frame = transaction[_i];
        this.messages.push(frame.body);
      }
      return delete this.transactions[frame.headers.transaction];
    };

    StompServerMock.prototype.stomp_handle_abort = function(frame) {
      return delete this.transactions[frame.headers.transaction];
    };

    StompServerMock.prototype.stomp_handle_send = function(frame) {
      if (frame.headers.transaction) {
        return this.transactions[frame.headers.transaction].push(frame);
      } else {
        return this.messages.push(frame);
      }
    };

    StompServerMock.prototype.stomp_handle_subscribe = function(frame) {
      var cb, sub_id,
        _this = this;
      sub_id = frame.headers.id || Math.random();
      cb = function(id, body) {
        return _this.stomp_send_message(frame.headers.destination, sub_id, id, body);
      };
      return this.subscriptions[sub_id] = [frame.headers.destination, cb];
    };

    StompServerMock.prototype.stomp_handle_unsubscribe = function(frame) {
      var _ref;
      if (_ref = frame.headers.id, __indexOf.call(Object.keys(this.subscriptions), _ref) >= 0) {
        return delete this.subscriptions[frame.headers.id];
      } else {
        return frame.headers.message = "Subscription does not exist";
      }
    };

    StompServerMock.prototype.stomp_handle_disconnect = function(frame) {
      return this._shutdown();
    };

    StompServerMock.prototype.test_send = function(sub_id, message) {
      var msgid;
      msgid = 'msg-' + Math.random();
      return this.subscriptions[sub_id][1](msgid, message);
    };

    return StompServerMock;

  })(WebSocketMock);

  exports.StompServerMock = StompServerMock;

}).call(this);
